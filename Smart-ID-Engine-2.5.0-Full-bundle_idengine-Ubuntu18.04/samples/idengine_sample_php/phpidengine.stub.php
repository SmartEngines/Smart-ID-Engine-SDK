<?php
//  Copyright (c) 2016-2024, Smart Engines Service LLC
//  All rights reserved.

// These stubs were generated by the phan stub generator.
// @phan-stub-for-extension phpidengine@

namespace {

class ByteString implements \SWIG\wrapped {

    // methods
    public function __construct(\ByteString|string $bytes_or_other) {}
    public function swap(\ByteString $other) : void {}
    public function GetLength() : int {}
    public function GetRequiredBase64BufferLength() : int {}
    public function CopyBase64ToBuffer(string $out_buffer, int $buffer_length) : int {}
    public function GetBase64String() : \MutableString {}
    public function GetRequiredHexBufferLength() : int {}
    public function CopyHexToBuffer(string $out_buffer, int $buffer_length) : int {}
    public function GetHexString() : \MutableString {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdAnimatedField implements \SWIG\wrapped {

    // methods
    /**
     * Main ctor for the animated field or copy
     * @param IdAnimatedField|string $name_or_copy - name of the field
     * @param bool $is_accepted - field's accept flag
     * @param float $confidence - field's confidence value (double in range [0.0, 1.0])
     */
    public function __construct(\IdAnimatedField|string $name_or_copy, bool $is_accepted = false, float $confidence = 0.0) {}
    public function GetName() : ?string {}
    public function SetName(string $name) : void {}
    public function GetFramesCount() : int {}
    public function GetFrame(int $frame_id) : \Image {}
    public function AppendFrame(\Image $frame) : void {}
    public function ClearFrames() : void {}
    public function GetBaseFieldInfo() : \IdBaseFieldInfo {}
    public function GetMutableBaseFieldInfo() : \IdBaseFieldInfo {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdAnimatedFieldsMapIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\IdAnimatedFieldsMapIterator $other) {}
    public function GetKey() : ?string {}
    public function GetValue() : \IdAnimatedField {}
    public function Equals(\IdAnimatedFieldsMapIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdBaseFieldInfo implements \SWIG\wrapped {

    // methods

    /**
     * Main ctor of the basic field information or copy
     * @param IdBaseFieldInfo|bool $is_accepted_or_copy - the accept flag (whether the field is accepted
     *        by the system)
     * @param float|null $confidence - the field's confidence (double in range [0.0, 1.0])
     */
    public function __construct(\IdBaseFieldInfo|bool $is_accepted_or_copy, float $confidence = null) {}
    public function GetIsAccepted() : bool {}
    public function SetIsAccepted(bool $is_accepted) : void {}
    public function GetConfidence() : float {}
    public function SetConfidence(float $confidence) : void {}
    public function GetAttributesCount() : int {}
    public function GetAttribute(string $attr_name) : ?string {}
    public function HasAttribute(string $attr_name) : bool {}
    public function SetAttribute(string $attr_name, string $attr_value) : void {}
    public function RemoveAttribute(string $attr_name) : void {}
    public function AttributesBegin() : \StringsMapIterator {}
    public function AttributesEnd() : \StringsMapIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdCheckField implements \SWIG\wrapped {

    // methods

    /**
     * Main ctor of the check field or copy
     * @param IdCheckField|string $name_or_copy - field's name
     * @param int|null $value - field's value (from the IdCheckStatus enumeration)
     * @param bool $is_accepted - field's accept flag
     * @param float $confidence - field's confidence value (double in range [0.0, 1.0])
     */
    public function __construct(\IdCheckField|string $name_or_copy, int $value = null, bool $is_accepted = false, float $confidence = 0.0) {}
    public function GetName() : ?string {}
    public function SetName(string $name) : void {}
    public function GetValue() : int {}
    public function SetValue(int $value) : void {}
    public function GetBaseFieldInfo() : \IdBaseFieldInfo {}
    public function GetMutableBaseFieldInfo() : \IdBaseFieldInfo {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdCheckFieldsMapIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\IdCheckFieldsMapIterator $other) {}
    public function GetKey() : ?string {}
    public function GetValue() : \IdCheckField {}
    public function Equals(\IdCheckFieldsMapIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdDocumentInfo implements \SWIG\wrapped {

    // methods
    public function GetDocumentName() : ?string {}
    public function GetDocumentDescription() : ?string {}
    public function HasRFID() : int {}
    public function GetPradoLinks() : \StringsSet {}
    public function GetDocumentTemplates() : \StringsSet {}
    public function GetDocumentFieldsRejectionThreshold(string $field_name) : float {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdEngine implements \SWIG\wrapped {

    // methods

    /**
     * Creates a Session Settings object with default recognition settings,
     *        specified in the configuration bundle.
     * @return IdSessionSettings|null A newly created IdSessionSettings object. The object is allocated,
     *         the caller is responsible for deleting it.
     */
    public function CreateSessionSettings() : ?\IdSessionSettings {}

    /**
     * Spawns a new documents recognition session
     * @param IdSessionSettings $settings - a settings object which are used to spawn a session
     * @param string $signature - a unique caller signature to unlock the internal
     *        library calls (provided with your SDK package)
     * @param IdFeedback|null $feedback_reporter - an optional pointer to the implementation of
     *        feedback callbacks class
     * @return IdSession|null newly created session (IdSession object). The object is
     *         allocated, the caller is responsible for deleting it.
     */
    public function SpawnSession(\IdSessionSettings $settings, string $signature, ?\IdFeedback $feedback_reporter = null) : ?\IdSession {}

    /**
     * Creates a File Analysis Session Settings object with default settings,
     *        specified in the configuration bundle.
     * @return IdFileAnalysisSessionSettings|null A newly created IdSessionSettings object. The object is allocated,
     *         the caller is responsible for deleting it.
     */
    public function CreateFileAnalysisSessionSettings() : ?\IdFileAnalysisSessionSettings {}

    /**
     * Spawns a new file analysis session
     * @param IdFileAnalysisSessionSettings $settings - a settings object which are used to spawn a session
     * @param string $signature - a unique caller signature to unlock the internal
     *        library calls (provided with your SDK package)
     * @return IdFileAnalysisSession|null A newly created session (IdSession object). The object is
     *         allocated, the caller is responsible for deleting it.
     */
    public function SpawnFileAnalysisSession(\IdFileAnalysisSessionSettings $settings, string $signature) : ?\IdFileAnalysisSession {}

    /**
     * Creates a Face Session Settings object with default face matching
     *        and processing settings, specified in the configuration bundle.
     * @return IdFaceSessionSettings|null A newly created IdFaceSessionSettings object. The object is
     *         allocated, the caller is responsible for deleting it.
     */
    public function CreateFaceSessionSettings() : ?\IdFaceSessionSettings {}

    /**
     * Spawns a new face matching and processing session
     * @param IdFaceSessionSettings $settings - face matching session settings which are used
     *        to spawn a new session
     * @param string $signature - a unique caller signature to unlock the internal
     *        library calls (provided with your SDK package)
     * @param IdFaceFeedback|null $feedback_reporter - an optional pointer to the implementation of
     *        face session feedback callbacks class
     * @return IdFaceSession|null A newly crated session (IdFaceSession object). The object is
     *         allocated, the caller is responsible for deleting it.
     */
    public function SpawnFaceSession(\IdFaceSessionSettings $settings, string $signature, ?\IdFaceFeedback $feedback_reporter = null) : ?\IdFaceSession {}

    /**
     * Create a Field Processing Session Settings object with default
     *        field processing settings, specified in the configuration bundle.
     * @return IdFieldProcessingSessionSettings|null A newly created IdFieldProcessingSessionSettings object. The
     *         object is allocated, the caller is responsible for deleting it.
     */
    public function CreateFieldProcessingSessionSettings() : ?\IdFieldProcessingSessionSettings {}

    /**
     * Spawns a new field processing session
     * @param IdFieldProcessingSessionSettings $settings - field processing session settings which are used to
     *        spawn a new session
     * @param string $signature - a unique caller signature to unlock the internal
     *        library calls (provided with your SDK package)
     * @return IdFieldProcessingSession|null A newly created IdFieldProcessingSession object. The object is
     *         allocated, the caller is responsible for deleting it.
     */
    public function SpawnFieldProcessingSession(\IdFieldProcessingSessionSettings $settings, string $signature) : ?\IdFieldProcessingSession {}

    /**
     * The factory method for creating the IdEngine object with a
     *        configuration bundle file.
     * @param string $config_path_or_config_data - filesystem path to a engine configuration bundle or pointer to the configuration bundle file buffer
     * @param bool $lazy_configuration - if true, some components of the internal
     *        engine structure will be initialized only when first needed. If
     *        false, all engine structure will be loaded and initialized
     *        immediately. Lazy configuration is enabled by default.
     * @param int $init_concurrency - allowed concurrent threads while configuring the
     *        engine. 0 means unlimited.
     * @param bool $delayed_initialization - performs a blank configuration, delaying
     *        the internal engines initialization until the corresponding
     *        SpawnSession method is called
     * @return IdEngine|null A newly created IdEngine object. The object is allocated,
     *         the caller is responsible for deleting it.
     */
    public static function Create(string $config_path_or_config_data, bool $lazy_configuration = true, int $init_concurrency = 0, bool $delayed_initialization = false) : ?\IdEngine {}

    /**
     * The factory method for creating the IdEngine object with a
     *        configuration bundle buffer embedded within the library.
     * @param bool $lazy_configuration - if true, some components of the internal
     *        engine structure will be initialized only when first needed. If
     *        false, all engine structure will be loaded and initialized
     *        immediately. Lazy configuration is enabled by default.
     * @param int $init_concurrency - allowed concurrent threads while configuring the
     *        engine. 0 means unlimited.
     * @param bool $delayed_initialization - performs a blank configuration, delaying
     *        the internal engines initialization until the corresponding
     *        SpawnSession method is called
     * @return IdEngine|null A newly created IdEngine object. The object is allocated,
     *         the caller is responsible for deleting it.
     */
    public static function CreateFromEmbeddedBundle(bool $lazy_configuration = true, int $init_concurrency = 0, bool $delayed_initialization = false) : ?\IdEngine {}

    /**
     * Returns the Smart ID Engine version number
     * @return string|null Smart ID Engine version number string
     */
    public static function GetVersion() : ?string {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFaceDescription implements \SWIG\wrapped {

    // methods

    /**
     * Factory method for creating an empty face description
     * @return IdFaceDescription|null Pointer to a created description. New object is allocated, the
     *         caller is responsible for deleting it.
     */
    public static function CreateEmpty() : ?\IdFaceDescription {}

    /**
     * Clones a face description
     * @return IdFaceDescription|null Pointer to a cloned description. New object is allocated, the
     *          caller is responsible for deleting it.
     */
    public function c_Clone() : ?\IdFaceDescription {}
    public function FaceDetected() : bool {}
    public function GetRectangle() : \Rectangle {}
    public function SetRectangle(\Rectangle $rect) : void {}
    public function GetOrientation() : int {}
    public function SetOrientation(int $orientation) : void {}
    public function HasVisualizationImage() : bool {}
    public function GetVisualizationImage() : \Image {}
    public function GetMutableVisualizationImage() : \Image {}
    public function SetVisualizationImage(\Image $image) : void {}
    public function GetFeatureVectorSize() : int {}
    public function GetFeature(int $index) : float {}
    public function SetFeature(int $index, float $value) : void {}
    public function ResizeFeatureVector(int $size) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFaceFeedback implements \SWIG\wrapped {

    // methods
    public function MessageReceived(string $message) {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFaceLivenessResult implements \SWIG\wrapped {

    // methods
    public function __construct(\IdFaceLivenessResult|float $liveness_estimation_or_copy) {}
    public function GetLivenessEstimation() : float {}
    public function SetLivenessEstimation(float $liveness_estimation) : void {}
    public function GetLivenessInstruction() : ?string {}
    public function SetLivenessInstruction(string $instruction) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFaceSession implements \SWIG\wrapped {

    // methods

    /**
     * Returns a unique activation request (required for builds with
     *        dynamic activation)
     * @return string|null an activation request string
     */
    public function GetActivationRequest() : ?string {}
    public function Activate(string $activation_response) : void {}
    public function IsActivated() : bool {}

    /**
     * Analyzes a face in the input image (independent from session state)
     * @param Image $face_image - input image to analyze
     * @return IdFaceDescription|null An IdFaceDescription object. The object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function GetFaceDescription(\Image $face_image) : ?\IdFaceDescription {}

    /**
     * Returns the similarity result for the two provided face images
     *        (independent from session state)
     * @param IdFaceDescription|Image $face_image_a_or_face_description_a - lvalue image for comparison or lvalue face description for comparison
     * @param IdFaceDescription|Image $face_image_b_or_face_description_b - rvalue image for comparison or rvalue face description for comparison
     * @return IdFaceSimilarityResult A similarity comparison result object
     */
    public function GetSimilarity(\IdFaceDescription|\Image $face_image_a_or_face_description_a, \IdFaceDescription|\Image $face_image_b_or_face_description_b) : \IdFaceSimilarityResult {}

    /**
     * Adds a new face image to the current session object
     * @param Image $face_image - the image of a face to be added
     */
    public function AddFaceImage(\Image $face_image) : void {}

    /**
     * Adds a new face image (by description) to the current session.
     *        This method is an alternative to AddFaceImage() if the caller
     *        already have described the face image.
     * @param IdFaceDescription $face_description - the description of a face to be added
     */
    public function AddFaceDescription(\IdFaceDescription $face_description) : void {}

    /**
     * Checks whether the session has an accumulated face description
     * @return bool Returns true iff the session has an accumulated face description
     */
    public function HasAccumulatedFaceDescription() : bool {}

    /**
     * Returns face description accumulated in the session
     * @return IdFaceDescription An IdFaceDescription (const ref) for the accumulated description
     */
    public function GetAccumulatedFaceDescription() : \IdFaceDescription {}

    /**
     * Returns the similarity result for the stream of images stored in the
     *        session state (lvalue) with an passed rvalue image
     * @param IdFaceDescription|Image $compare_image_or_compare_description - the rvalue image to compare the state with or rvalue description to compare the state with
     * @return IdFaceSimilarityResult A similarity comparison result object
     */
    public function GetSimilarityWith(\IdFaceDescription|\Image $compare_image_or_compare_description) : \IdFaceSimilarityResult {}

    /**
     * Returns the liveness estimation result for the stream of images
     *        passed through the session
     * @return IdFaceLivenessResult A liveness estimation result object
     */
    public function GetLivenessResult() : \IdFaceLivenessResult {}
    public function Reset() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFaceSessionSettings implements \SWIG\wrapped {

    // methods

    /**
     * Clones the settings object.
     * @return IdFaceSessionSettings|null A newly created object with the same contents as the current
     *         instance. The object is allocated, the caller is responsible
     *         for deleting it.
     */
    public function c_Clone() : ?\IdFaceSessionSettings {}
    public function GetOptionsCount() : int {}
    public function GetOption(string $option_name) : ?string {}
    public function HasOption(string $option_name) : bool {}
    public function SetOption(string $option_name, string $option_value) : void {}
    public function RemoveOption(string $option_name) : void {}
    public function OptionsBegin() : \StringsMapIterator {}
    public function OptionsEnd() : \StringsMapIterator {}
    public function GetSupportedLivenessInstructionsCount() : int {}
    public function HasSupportedLivenessInstruction(string $instruction) : bool {}
    public function GetLivenessInstructionDescription(string $instruction) : ?string {}
    public function SupportedLivenessInstructionsBegin() : \StringsMapIterator {}
    public function SupportedLivenessInstructionsEnd() : \StringsMapIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFaceSimilarityResult implements \SWIG\wrapped {

    // methods
    public function __construct(\IdFaceSimilarityResult|float $similarity_estimation_or_copy, int $status = null) {}
    public function GetSimilarityEstimation() : float {}
    public function SetSimilarityEstimation(float $similarity_estimation) : void {}
    public function GetStatus() : int {}
    public function SetStatus(int $status) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFeedback implements \SWIG\wrapped {

    // methods

    /**
     * Callback for receiving visualization container
     * @param IdFeedbackContainer $feedback_container - the received visualization container
     *        (a collection of named quadrangles)
     */
    public function FeedbackReceived(\IdFeedbackContainer $feedback_container) {}

    /**
     * Callback for receiving a document page (template) detection result
     * @param IdTemplateDetectionResult $detection_result - the received document page (template) detection result
     */
    public function TemplateDetectionResultReceived(\IdTemplateDetectionResult $detection_result) {}

    /**
     * Callback for receiving a page (template) segmentation result
     * @param IdTemplateSegmentationResult $segmentation_result - the received document page (template) segmentation result
     */
    public function TemplateSegmentationResultReceived(\IdTemplateSegmentationResult $segmentation_result) {}

    /**
     * Callback for receiving a full document recognition result
     * @param IdResult $result_received - the received document recognition result
     */
    public function ResultReceived(\IdResult $result_received) {}

    /**
     * Callback which is called when the video stream recognition session
     *        ends (the result becomes terminal).
     */
    public function SessionEnded() {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFeedbackContainer implements \SWIG\wrapped {

    // methods
    public function __construct(\IdFeedbackContainer $copy) {}
    public function GetQuadranglesCount() : int {}
    public function HasQuadrangle(string $quad_name) : bool {}
    public function GetQuadrangle(string $quad_name) : \Quadrangle {}
    public function SetQuadrangle(string $quad_name, \Quadrangle $quad) : void {}
    public function RemoveQuadrangle(string $quad_name) : void {}
    public function QuadranglesBegin() : \QuadranglesMapIterator {}
    public function QuadranglesEnd() : \QuadranglesMapIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFieldProcessingSession implements \SWIG\wrapped {

    // methods

    /**
     * Returns a unique activation request (required for builds with
     *        dynamic activation)
     * @return string|null an activation request string
     */
    public function GetActivationRequest() : ?string {}
    public function Activate(string $activation_response) : void {}
    public function IsActivated() : bool {}
    public function Process() : void {}
    public function GetTextFieldsCount() : int {}
    public function HasTextField(string $field_name) : bool {}
    public function GetTextField(string $field_name) : \IdTextField {}
    public function SetTextField(string $field_name, \IdTextField $field) : void {}
    public function RemoveTextField(string $field_name) : void {}
    public function TextFieldsBegin() : \IdTextFieldsMapIterator {}
    public function TextFieldsEnd() : \IdTextFieldsMapIterator {}
    public function GetImageFieldsCount() : int {}
    public function HasImageField(string $field_name) : bool {}
    public function GetImageField(string $field_name) : \IdImageField {}
    public function SetImageField(string $field_name, \IdImageField $field) : void {}
    public function RemoveImageField(string $field_name) : void {}
    public function ImageFieldsBegin() : \IdImageFieldsMapIterator {}
    public function ImageFieldsEnd() : \IdImageFieldsMapIterator {}
    public function GetAnimatedFieldsCount() : int {}
    public function HasAnimatedField(string $field_name) : bool {}
    public function GetAnimatedField(string $field_name) : \IdAnimatedField {}
    public function SetAnimatedField(string $field_name, \IdAnimatedField $field) : void {}
    public function RemoveAnimatedField(string $field_name) : void {}
    public function AnimatedFieldsBegin() : \IdAnimatedFieldsMapIterator {}
    public function AnimatedFieldsEnd() : \IdAnimatedFieldsMapIterator {}
    public function GetCheckFieldsCount() : int {}
    public function HasCheckField(string $field_name) : bool {}
    public function GetCheckField(string $field_name) : \IdCheckField {}
    public function SetCheckField(string $field_name, \IdCheckField $field) : void {}
    public function RemoveCheckField(string $field_name) : void {}
    public function CheckFieldsBegin() : \IdCheckFieldsMapIterator {}
    public function CheckFieldsEnd() : \IdCheckFieldsMapIterator {}
    public function Reset() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFieldProcessingSessionSettings implements \SWIG\wrapped {

    // methods

    /**
     * Clones the settings object
     * @return IdFieldProcessingSessionSettings|null A new object with the same state as the current instance. The newly
     *         created object is allocated, the caller is responsible for
     *         deleting it
     */
    public function c_Clone() : ?\IdFieldProcessingSessionSettings {}
    public function GetSupportedFieldProcessorsCount() : int {}
    public function HasSupportedFieldProcessor(string $field_processor_name) : bool {}
    public function SupportedFieldProcessorsBegin() : \StringsSetIterator {}
    public function SupportedFieldProcessorsEnd() : \StringsSetIterator {}
    public function GetCurrentFieldProcessor() : ?string {}
    public function SetCurrentFieldProcessor(string $field_processor_name) : void {}
    public function GetOptionsCount() : int {}
    public function GetOption(string $option_name) : ?string {}
    public function HasOption(string $option_name) : bool {}
    public function SetOption(string $option_name, string $option_value) : void {}
    public function RemoveOption(string $option_name) : void {}
    public function OptionsBegin() : \StringsMapIterator {}
    public function OptionsEnd() : \StringsMapIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFileAnalysisSession implements \SWIG\wrapped {

    // methods

    /**
     * Returns a unique activation request (required for builds with
     *        dynamic activation)
     * @return string|null an activation request string
     */
    public function GetActivationRequest() : ?string {}
    public function Activate(string $activation_response) : void {}
    public function IsActivated() : bool {}

    /**
     * Processes the input image (or frame)
     * @param Image $image - the input image (or a frame of a video sequence)
     * @return IdResult The updated file_analysis result (const ref)
     */
    public function Process(\Image $image) : \IdResult {}
    public function GetCurrentResult() : \IdResult {}
    public function Reset() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdFileAnalysisSessionSettings implements \SWIG\wrapped {

    // methods

    /**
     * Clones the settings object
     * @return IdFileAnalysisSessionSettings|null A new object with the same state as the current instance. The newly
     *         created object is allocated, the caller is responsible for
     *         deleting it
     */
    public function c_Clone() : ?\IdFileAnalysisSessionSettings {}
    public function GetOptionsCount() : int {}
    public function GetOption(string $option_name) : ?string {}
    public function HasOption(string $option_name) : bool {}
    public function SetOption(string $option_name, string $option_value) : void {}
    public function RemoveOption(string $option_name) : void {}
    public function OptionsBegin() : \StringsMapIterator {}
    public function OptionsEnd() : \StringsMapIterator {}
    public function GetSupportedForensicFieldsCount() : int {}
    public function HasSupportedForensicField(string $field_name) : bool {}
    public function SupportedForensicFieldsBegin() : \StringsSetIterator {}
    public function SupportedForensicFieldsEnd() : \StringsSetIterator {}
    public function GetEnabledForensicFieldsCount() : int {}
    public function HasEnabledForensicField(string $field_name) : bool {}
    public function EnabledForensicFieldsBegin() : \StringsSetIterator {}
    public function EnabledForensicFieldsEnd() : \StringsSetIterator {}
    public function EnableForensicField(string $field_name) : void {}
    public function DisableForensicField(string $field_name) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdImageField implements \SWIG\wrapped {

    // methods

    /**
     * Main ctor of an image field
     * @param IdImageField|string $name_or_copy - name of the field or copy
     * @param Image|null $value - value of the field (image content)
     * @param bool $is_accepted - the field's accept flag
     * @param float $confidence - the field's confidence (double in range [0.0, 1.0])
     */
    public function __construct(\IdImageField|string $name_or_copy, \Image $value = null, bool $is_accepted = false, float $confidence = 0.0) {}
    public function GetName() : ?string {}
    public function SetName(string $name) : void {}
    public function GetValue() : \Image {}
    public function SetValue(\Image $value) : void {}
    public function GetBaseFieldInfo() : \IdBaseFieldInfo {}
    public function GetMutableBaseFieldInfo() : \IdBaseFieldInfo {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdImageFieldsMapIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\IdImageFieldsMapIterator $other) {}
    public function GetKey() : ?string {}
    public function GetValue() : \IdImageField {}
    public function Equals(\IdImageFieldsMapIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdResult implements \SWIG\wrapped {

    // methods
    public function __construct(\IdResult|bool $is_terminal_or_copy) {}
    public function GetDocumentType() : ?string {}
    public function SetDocumentType(string $document_type) : void {}
    public function GetTemplateDetectionResultsCount() : int {}
    public function GetTemplateDetectionResult(int $result_id) : \IdTemplateDetectionResult {}
    public function AppendTemplateDetectionResult(\IdTemplateDetectionResult $result) : void {}
    public function ClearTemplateDetectionResults() : void {}
    public function GetTemplateSegmentationResultsCount() : int {}
    public function GetTemplateSegmentationResult(int $result_id) : \IdTemplateSegmentationResult {}
    public function AppendTemplateSegmentationResult(\IdTemplateSegmentationResult $result) : void {}
    public function ClearTemplateSegmentationResults() : void {}
    public function GetIsTerminal() : bool {}
    public function SetIsTerminal(bool $is_terminal) : void {}
    public function GetSeenTemplates() : \StringsSet {}
    public function GetTerminalTemplates() : \StringsSet {}
    public function GetTextFieldsCount() : int {}
    public function HasTextField(string $field_name) : bool {}
    public function GetTextField(string $field_name) : \IdTextField {}
    public function SetTextField(string $field_name, \IdTextField $field) : void {}
    public function RemoveTextField(string $field_name) : void {}
    public function TextFieldsBegin() : \IdTextFieldsMapIterator {}
    public function TextFieldsEnd() : \IdTextFieldsMapIterator {}
    public function GetImageFieldsCount() : int {}
    public function HasImageField(string $field_name) : bool {}
    public function GetImageField(string $field_name) : \IdImageField {}
    public function SetImageField(string $field_name, \IdImageField $field) : void {}
    public function RemoveImageField(string $field_name) : void {}
    public function ImageFieldsBegin() : \IdImageFieldsMapIterator {}
    public function ImageFieldsEnd() : \IdImageFieldsMapIterator {}
    public function GetAnimatedFieldsCount() : int {}
    public function HasAnimatedField(string $field_name) : bool {}
    public function GetAnimatedField(string $field_name) : \IdAnimatedField {}
    public function SetAnimatedField(string $field_name, \IdAnimatedField $field) : void {}
    public function RemoveAnimatedField(string $field_name) : void {}
    public function AnimatedFieldsBegin() : \IdAnimatedFieldsMapIterator {}
    public function AnimatedFieldsEnd() : \IdAnimatedFieldsMapIterator {}
    public function GetCheckFieldsCount() : int {}
    public function HasCheckField(string $field_name) : bool {}
    public function GetCheckField(string $field_name) : \IdCheckField {}
    public function SetCheckField(string $field_name, \IdCheckField $field) : void {}
    public function RemoveCheckField(string $field_name) : void {}
    public function CheckFieldsBegin() : \IdCheckFieldsMapIterator {}
    public function CheckFieldsEnd() : \IdCheckFieldsMapIterator {}
    public function GetForensicTextFieldsCount() : int {}
    public function HasForensicTextField(string $field_name) : bool {}
    public function GetForensicTextField(string $field_name) : \IdTextField {}
    public function SetForensicTextField(string $field_name, \IdTextField $field) : void {}
    public function RemoveForensicTextField(string $field_name) : void {}
    public function ForensicTextFieldsBegin() : \IdTextFieldsMapIterator {}
    public function ForensicTextFieldsEnd() : \IdTextFieldsMapIterator {}
    public function GetForensicImageFieldsCount() : int {}
    public function HasForensicImageField(string $field_name) : bool {}
    public function GetForensicImageField(string $field_name) : \IdImageField {}
    public function SetForensicImageField(string $field_name, \IdImageField $field) : void {}
    public function RemoveForensicImageField(string $field_name) : void {}
    public function ForensicImageFieldsBegin() : \IdImageFieldsMapIterator {}
    public function ForensicImageFieldsEnd() : \IdImageFieldsMapIterator {}
    public function GetForensicAnimatedFieldsCount() : int {}
    public function HasForensicAnimatedField(string $field_name) : bool {}
    public function GetForensicAnimatedField(string $field_name) : \IdAnimatedField {}
    public function SetForensicAnimatedField(string $field_name, \IdAnimatedField $field) : void {}
    public function RemoveForensicAnimatedField(string $field_name) : void {}
    public function ForensicAnimatedFieldsBegin() : \IdAnimatedFieldsMapIterator {}
    public function ForensicAnimatedFieldsEnd() : \IdAnimatedFieldsMapIterator {}
    public function GetForensicCheckFieldsCount() : int {}
    public function HasForensicCheckField(string $field_name) : bool {}
    public function GetForensicCheckField(string $field_name) : \IdCheckField {}
    public function SetForensicCheckField(string $field_name, \IdCheckField $field) : void {}
    public function RemoveForensicCheckField(string $field_name) : void {}
    public function ForensicCheckFieldsBegin() : \IdCheckFieldsMapIterator {}
    public function ForensicCheckFieldsEnd() : \IdCheckFieldsMapIterator {}
    public function GetRawTextFieldsCount() : int {}
    public function HasRawTextField(string $field_name) : bool {}
    public function GetRawTextField(string $field_name) : \IdTextField {}
    public function SetRawTextField(string $field_name, \IdTextField $field) : void {}
    public function RemoveRawTextField(string $field_name) : void {}
    public function RawTextFieldsBegin() : \IdTextFieldsMapIterator {}
    public function RawTextFieldsEnd() : \IdTextFieldsMapIterator {}
    public function GetRawImageFieldsCount() : int {}
    public function HasRawImageField(string $field_name) : bool {}
    public function GetRawImageField(string $field_name) : \IdImageField {}
    public function SetRawImageField(string $field_name, \IdImageField $field) : void {}
    public function RemoveRawImageField(string $field_name) : void {}
    public function RawImageFieldsBegin() : \IdImageFieldsMapIterator {}
    public function RawImageFieldsEnd() : \IdImageFieldsMapIterator {}
    public function GetCorrespondingRawFieldsCount(string $field_name) : int {}
    public function HasCorrespondingRawField(string $field_name, string $raw_field_name) : bool {}
    public function CorrespondingRawFieldNamesBegin(string $field_name) : \StringsSetIterator {}
    public function CorrespondingRawFieldNamesEnd(string $field_name) : \StringsSetIterator {}
    public function GetCorrespondingFieldsCount(string $raw_field_name) : int {}
    public function HasCorrespondingField(string $raw_field_name, string $field_name) : bool {}
    public function CorrespondingFieldNamesBegin(string $raw_field_name) : \StringsSetIterator {}
    public function CorrespondingFieldNamesEnd(string $raw_field_name) : \StringsSetIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdSession implements \SWIG\wrapped {

    // methods

    /**
     * Get an activation request for this session (valid for SDK built with dynamic activation feature)
     * @return string|null A string with activation request
     */
    public function GetActivationRequest() : ?string {}

    /**
     * Activate current session (valid for SDK built with dynamic activation feature)
     * @param string $activation_response - the response from activation server
     */
    public function Activate(string $activation_response) : void {}

    /**
     * Check if current session was activated (valid for SDK built with dynamic activation    feature)
     * @return bool Boolen check (true/false)
     */
    public function IsActivated() : bool {}

    /**
     * Processes the input image (or frame)
     * @param ByteString|Image $image_or_data - the input image (or a frame of a video sequence)
     * @return IdResult The updated document recognition result (const ref)
     */
    public function Process(\ByteString|\Image $image_or_data) : \IdResult {}
    public function GetCurrentResult() : \IdResult {}
    public function IsResultTerminal() : bool {}
    public function Reset() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdSessionSettings implements \SWIG\wrapped {

    // methods

    /**
     * Clones the session settings object
     * @return IdSessionSettings|null A new object of session settings with an identical state. A newly
     *         created object is allocated, the caller is responsible for
     *         deleting it
     */
    public function c_Clone() : ?\IdSessionSettings {}
    public function GetOptionsCount() : int {}
    public function GetOption(string $option_name) : ?string {}
    public function HasOption(string $option_name) : bool {}
    public function SetOption(string $option_name, string $option_value) : void {}
    public function RemoveOption(string $option_name) : void {}
    public function OptionsBegin() : \StringsMapIterator {}
    public function OptionsEnd() : \StringsMapIterator {}
    public function GetSupportedModesCount() : int {}
    public function HasSupportedMode(string $mode_name) : bool {}
    public function SupportedModesBegin() : \StringsSetIterator {}
    public function SupportedModesEnd() : \StringsSetIterator {}
    public function GetCurrentMode() : ?string {}
    public function SetCurrentMode(string $mode_name) : void {}
    public function GetInternalEnginesCount() : int {}
    public function HasInternalEngine(string $engine_name) : bool {}
    public function InternalEngineNamesBegin() : \StringsSetIterator {}
    public function InternalEngineNamesEnd() : \StringsSetIterator {}
    public function GetSupportedDocumentTypesCount(string $engine_name) : int {}
    public function HasSupportedDocumentType(string $engine_name, string $doc_name) : bool {}
    public function SupportedDocumentTypesBegin(string $engine_name) : \StringsSetIterator {}
    public function SupportedDocumentTypesEnd(string $engine_name) : \StringsSetIterator {}
    public function GetEnabledDocumentTypesCount() : int {}
    public function HasEnabledDocumentType(string $doc_name) : bool {}
    public function EnabledDocumentTypesBegin() : \StringsSetIterator {}
    public function EnabledDocumentTypesEnd() : \StringsSetIterator {}

    /**
     * Adds enabled document types to the session settings, within the
     *        currently active mode
     * @param string $doc_type_mask - a document type, or a mask with wildcards ('*'). The
     *        wildcard symbol will match any sequence of characters, and the
     *        lookup dictionary for matched document types are taken from the set
     *        of supported document types within the currently active mode.
     * 
     * NB: the set of matched document types must belong to a single
     *          internal engine.
     */
    public function AddEnabledDocumentTypes(string $doc_type_mask) : void {}

    /**
     * Removes the document types from the set of enabled ones
     * @param string $doc_type_mask - a document type, or a mask with wildcards ('*'). The
     *        wildcard symbol will match any sequence of characters, and the
     *        lookup dictionary for matched document types are taken from the set
     *        of supported document types within the currently active mode.
     */
    public function RemoveEnabledDocumentTypes(string $doc_type_mask) : void {}
    public function GetDocumentInfo(string $doc_name) : \IdDocumentInfo {}
    public function GetSupportedFieldsCount(string $doc_name) : int {}
    public function HasSupportedField(string $doc_name, string $field_name) : bool {}
    public function SupportedFieldsBegin(string $doc_name) : \StringsSetIterator {}
    public function SupportedFieldsEnd(string $doc_name) : \StringsSetIterator {}
    public function GetFieldType(string $doc_name, string $field_name) : int {}
    public function GetEnabledFieldsCount(string $doc_name) : int {}
    public function HasEnabledField(string $doc_name, string $field_name) : bool {}
    public function EnabledFieldsBegin(string $doc_name) : \StringsSetIterator {}
    public function EnabledFieldsEnd(string $doc_name) : \StringsSetIterator {}
    public function EnableField(string $doc_name, string $field_name) : void {}
    public function DisableField(string $doc_name, string $field_name) : void {}
    public function IsForensicsEnabled() : bool {}
    public function EnableForensics() : void {}
    public function DisableForensics() : void {}
    public function GetSupportedForensicFieldsCount(string $doc_name) : int {}
    public function HasSupportedForensicField(string $doc_name, string $field_name) : bool {}
    public function SupportedForensicFieldsBegin(string $doc_name) : \StringsSetIterator {}
    public function SupportedForensicFieldsEnd(string $doc_name) : \StringsSetIterator {}
    public function GetForensicFieldType(string $doc_name, string $field_name) : int {}
    public function GetEnabledForensicFieldsCount(string $doc_name) : int {}
    public function HasEnabledForensicField(string $doc_name, string $field_name) : bool {}
    public function EnabledForensicFieldsBegin(string $doc_name) : \StringsSetIterator {}
    public function EnabledForensicFieldsEnd(string $doc_name) : \StringsSetIterator {}
    public function EnableForensicField(string $doc_name, string $field_name) : void {}
    public function DisableForensicField(string $doc_name, string $field_name) : void {}
    public function PermissiblePrefixDocMasksBegin() : \StringsSetIterator {}
    public function PermissiblePrefixDocMasksEnd() : \StringsSetIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdTemplateDetectionResult implements \SWIG\wrapped {

    // methods

    /**
     * Main ctor of the template detection result
     * @param IdTemplateDetectionResult|string $tpl_name_or_copy - name of the detected document page (template) or copy
     * @param Quadrangle|null $quadrangle - quadrangle of the detected template in an image
     * @param bool $is_accepted - detected template's accept flag
     * @param float|null $confidence - detected template's confidence (double in [0.0, 1.0])
     * @param Size|null $standard_size - the standard size of the template in pixels
     */
    public function __construct(\IdTemplateDetectionResult|string $tpl_name_or_copy, \Quadrangle $quadrangle = null, bool $is_accepted = null, float $confidence = null, \Size $standard_size = null) {}
    public function GetTemplateName() : ?string {}
    public function SetTemplateName(string $name) : void {}
    public function GetQuadrangle() : \Quadrangle {}
    public function SetQuadrangle(\Quadrangle $quadrangle) : void {}
    public function GetIsAccepted() : bool {}
    public function SetIsAccepted(bool $is_accepted) : void {}
    public function GetConfidence() : float {}
    public function SetConfidence(float $confidence) : void {}
    public function GetStandardSize() : \Size {}
    public function SetStandardSize(\Size $standard_size) : void {}
    public function GetAttributesCount() : int {}
    public function GetAttribute(string $attr_name) : ?string {}
    public function HasAttribute(string $attr_name) : bool {}
    public function SetAttribute(string $attr_name, string $attr_value) : void {}
    public function RemoveAttribute(string $attr_name) : void {}
    public function AttributesBegin() : \StringsMapIterator {}
    public function AttributesEnd() : \StringsMapIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdTemplateSegmentationResult implements \SWIG\wrapped {

    // methods

    /**
     * Main ctor of the template segmentation result
     * @param IdTemplateSegmentationResult|bool $is_accepted_or_copy - the segmentation result's accept flag or copy
     * @param float|null $confidence - the segmentation result's confidence (in [0.0, 1.0])
     */
    public function __construct(\IdTemplateSegmentationResult|bool $is_accepted_or_copy, float $confidence = null) {}
    public function GetIsAccepted() : bool {}
    public function SetIsAccepted(bool $is_accepted) : void {}
    public function GetConfidence() : float {}
    public function SetConfidence(float $confidence) : void {}
    public function GetRawFieldsCount() : int {}
    public function HasRawField(string $raw_field_name) : bool {}
    public function GetRawFieldQuadrangle(string $raw_field_name) : \Quadrangle {}
    public function GetRawFieldTemplateQuadrangle(string $raw_field_name) : \Quadrangle {}
    public function SetRawFieldQuadrangles(string $raw_field_name, \Quadrangle $quadrangle, \Quadrangle $template_quadrangle) : void {}
    public function RemoveRawField(string $raw_field_name) : void {}
    public function RawFieldQuadranglesBegin() : \QuadranglesMapIterator {}
    public function RawFieldQuadranglesEnd() : \QuadranglesMapIterator {}
    public function RawFieldTemplateQuadranglesBegin() : \QuadranglesMapIterator {}
    public function RawFieldTemplateQuadranglesEnd() : \QuadranglesMapIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdTextField implements \SWIG\wrapped {

    // methods

    /**
     * Main ctor of the text field
     * @param IdTextField|string $name_or_copy - name of the text field or copy
     * @param OcrString|string|null $value - the value of the text field as an OcrString object
     * @param bool $is_accepted - the field's accept flag
     * @param float $confidence - the field's confidence (double in range [0.0, 1.0])
     */
    public function __construct(\IdTextField|string $name_or_copy, \OcrString|string $value = null, bool $is_accepted = false, float $confidence = 0.0) {}
    public function GetName() : ?string {}
    public function SetName(string $name) : void {}
    public function GetValue() : \OcrString {}
    public function SetValue(\OcrString|string $value) : void {}
    public function GetBaseFieldInfo() : \IdBaseFieldInfo {}
    public function GetMutableBaseFieldInfo() : \IdBaseFieldInfo {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class IdTextFieldsMapIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\IdTextFieldsMapIterator $other) {}
    public function GetKey() : ?string {}
    public function GetValue() : \IdTextField {}
    public function Equals(\IdTextFieldsMapIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class Image implements \SWIG\wrapped {

    // methods

    /**
     * Returns the number of pages in an image
     * @param string $image_filename path to an imag file
     * @return int the number of pages in an image
     */
    public static function GetNumberOfPages(string $image_filename) : int {}

    /**
     * Returns the name of the specified page.
     * @param string $image_filename     SThe filename of the image to process.
     * @param int $page_number        0-based page number.
     * @return MutableString Separate page filename.
     */
    public static function GetImagePageName(string $image_filename, int $page_number) : \MutableString {}

    /**
     * Factory method for creating an empty image
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public static function CreateEmpty() : ?\Image {}

    /**
     * Factory method for loading an image from file.
     *        Will be treated as IPF_G or IPF_RGB.
     * @param string $image_filename path to an image file (png, jpg, tif)
     * @param int $page_number page number (0 by default)
     * @param Size|null $max_size maximum image size in pixels (0 for unrestricted)
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public static function FromFile(string $image_filename, int $page_number = 0, \Size $max_size = null) : ?\Image {}

    /**
     * Factory method for loading an image from file pre-loaded in a buffer
     *        Will be treated as IPF_G or IPF_RGB.
     * @param string $data is pixels buffer
     * @param int $page_number page number (0 by default)
     * @param Size|null $max_size maximum image size in pixels (0 for unrestricted)
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public static function FromFileBuffer(string $data, int $page_number = 0, \Size $max_size = null) : ?\Image {}

    /**
     * Factory method for loading an image from uncompressed pixels buffer,
     *        with UINT8 channel container. Copies the buffer internally.
     *        Buffers with types IPF_G, IPF_RGB, and IPF_BGRA are assumed.
     * @param string $raw_data is pixels buffer
     * @param int $width width of the image in pixels
     * @param int $height height of the image in pixels
     * @param int $stride size of an image row in bytes (including alignment)
     * @param int $channels number of channels per-pixel
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public static function FromBuffer(string $raw_data, int $width, int $height, int $stride, int $channels) : ?\Image {}

    /**
     * Factory method for loading an image from an uncompressed pixel
     *        buffer with extended settings. Copies the buffer internally.
     * @param string $raw_data is pixels buffer
     * @param int $width width of the image in pixels
     * @param int $height height of the image in pixels
     * @param int $stride size of an image row in bytes (including alignment)
     * @param int $pixel_format pixel format
     * @param int $bytes_per_channel size of a pixel component in bytes
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */  
    public static function FromBufferExtended(string $raw_data, int $width, int $height, int $stride, int $pixel_format, int $bytes_per_channel) : ?\Image {}

    /**
     * Factory method for loading an image from YUV NV21 buffer
     * @param string $yuv_data is pixels buffer
     * @param int $width width of the image in pixels
     * @param int $height height of the image in pixels
     * @return Image Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public static function FromYUVBuffer(string $yuv_data, int $width, int $height) : ?\Image {}

    /**
     * Factory method for loading an image from a universal YUV buffer.
     * @param string $y_plane is pixels buffer
     * @param string $u_plane is pixels buffer
     * @param string $v_plane is pixels buffer
     * @param YUVDimensions $dimensions YUV parameters and dimensions
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public static function FromYUV(string $y_plane, string $u_plane, string $v_plane, \YUVDimensions $dimensions) : ?\Image {}

    /**
     * Factory method for loading an image from file pre-loaded in a buffer
     *        encoded as a Base64 string. Will be treated as IPF_G or IPF_RGB.
     * @param string $base64_buffer pointer to a base64 file buffer
     * @param int $page_number page number (0 by default)
     * @param Size|null $max_size maximum image size in pixels (0 for unrestricted)
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public static function FromBase64Buffer(string $base64_buffer, int $page_number = 0, \Size $max_size = null) : ?\Image {}

    /**
     * Gets the number of additional layers
     * @return int The number of layers
     */
    public function GetNumberOfLayers() : int {}

    /**
     * Gets the additional layer by the specified name
     * @param string $name the name of the required layer
     * @return Image The layer
     */
    public function GetLayer(string $name) : \Image {}

    /**
     * Gets the additional layer by the specified name
     * @param string $name the name of the required layer
     * @return Image|null The pointer to the layer
     */   
    public function GetLayerPtr(string $name) : ?\Image {}

    /**
     * Gets the 'begin' map iterator to the internal layers collection
     * @return ImagesMapIterator The 'begin' map iterator to the internal layers collection
     */
    public function LayersBegin() : \ImagesMapIterator {}

    /**
     * Gets the 'end' map iterator to the internal layers collection
     * @return ImagesMapIterator The 'end' map iterator to the internal layers collection
     */
    public function LayersEnd() : \ImagesMapIterator {}

    /**
     * Checks whether the Image contains the layer with the specified name
     * @param string $name the name of the required layer
     * @return bool whether the Image contains the layer with the specified name
     */
    public function HasLayer(string $name) : bool {}

    /**
     * Checks whether the Image contains the layers
     * @return bool whether the Image contains the layers
     */
    public function HasLayers() : bool {}

    /**
     * Removes the layer with the specified name
     * @param string $name the name of the removable layer
     */
    public function RemoveLayer(string $name) : void {}

    /**
     *  Clears the internal layers collection
     */
    public function RemoveLayers() : void {}

    /**
     * Add the image with the specified name to the internal layers collection 
     *        with copying of the pixels of the given image.
     * @param string $name the name of the new layer
     * @param Image $image the value of the new layer
     */
    public function SetLayer(string $name, \Image $image) : void {}

    /**
     * Add the image with the specified name to the internal layers collection
     *        by transfering the given image to the internal layers collection.
     *        The caller has to release the ownership of the set image.
     * @param string $name the name of the new layer
     * @param Image|null $image the pointer to the value of the new layer
     */
    public function SetLayerWithOwnership(string $name, ?\Image $image) : void {}

    /**
     * Clones an image with copying of all pixels
     * @return Image Pointer to a cloned image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneDeep() : ?\Image {}

    /**
     * Clones an image without copying the pixels. The cloned image will
     *        be a separate object without memory ownership, the operations with
     *        it will be invalid if the source is deallocated.
     * @return Image|null Pointer to a cloned image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneShallow() : ?\Image {}

    /**
     *  Clears the internal image structure
     */
    public function Clear() : void {}

    /**
     * Gets the required buffer length for copying the image pixels into
     *        an external pixels buffer
     * @return int Number of required bytes
     */
    public function GetRequiredBufferLength() : int {}

    /**
     * Copies the image pixels
     * @param string $buffer is pixels buffer
     * @return int The number of written bytes
     */
    public function CopyToBuffer(string $buffer) : int {}
 
    /**
     * Saves the image to an external file (png, jpg, tif). Format is
     *        deduced from the filename extension
     * @param string $image_filename filename to save the image
     */
    public function Save(string $image_filename) : void {}
 
    /**
     * Returns required buffer size for Base64 JPEG representation of an
     *        image. WARNING: will perform one extra JPEG encoding of an image
     * @return int Buffer size in bytes.
     */
    public function GetRequiredBase64BufferLength() : int {}

    /**
     * Copies the Base64 JPEG representation of an image to an external
     *        buffer.
     * @param string $out_buffer is pixels buffer
     * @param int $buffer_length buffer length in pixels
     * @return int The number of written bytes.
     */   
    public function CopyBase64ToBuffer(string $out_buffer, int $buffer_length) : int {}

    /**
     * Returns Base64 JPEG representation of an image
     * @return MutableString Base64 JPEG representation in a MutableString form
     */
    public function GetBase64String() : \MutableString {}

    /**
     * Estimates focus score of an image
     * @param float $quantile the derivatives quantile used to estimate focus score
     * @return float floatFocus score of an image
     */
    public function EstimateFocusScore(float $quantile = 0.95) : float {}

    /**
     * Scale the image to a new size
     * @param Size $new_size new size of the image
     */
    public function Resize(\Size $new_size) : void {}

    /**
     * Clones the image scaled to a new size
     * @param Size $new_size new size of the image
     * @return Image|null Pointer to a scaled image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneResized(\Size $new_size) : ?\Image {}

    /**
     * Projectively crops a region of image, with approximate selection
     *        of the cropped image size
     * @param Quadrangle|Rectangle $quad_or_rect quadrangle or rectangle in the image for cropping.
     * @param Size|null $size target cropped image size
     */
    public function Crop(\Quadrangle|\Rectangle $quad_or_rect, \Size $size = null) : void {}

    /**
     * Clones the image projectively cropped with approximate selection
     *        of the target image size
     * @param Quadrangle|Rectangle $quad_or_rect quadrangle or rectangle in the image for cropping
     * @param Size|null $size target cropped image size
     * @return Image|null Pointer to a cropped image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneCropped(\Quadrangle|\Rectangle $quad_or_rect, \Size $size = null) : ?\Image {}

    /**
     * Clones the image cropped to a selected rectangular region, without
     *        copying of pixels. The cloned image will be a separate object
     *        without memory ownership, the operations with it will be invalid if
     *        the source is deallocated.
     * @param Rectangle $rect rectangular region to crop
     * @return Image|null Pointer to a cropped image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneCroppedShallow(\Rectangle $rect) : ?\Image {}

    /**
     * Masks image region specified by rectangle
     * @param Quadrangle|Rectangle $rect_or_quad rectangle region or quadrangle region to mask
     * @param pixel_expand $pixel_expand expand offset in pixels for each point (0 by default)
     */
    public function Mask(\Quadrangle|\Rectangle $rect_or_quad, int $pixel_expand = 0) : void {}

    /**
     * Clone the image with masked region specified by rectangle
     * @param Quadrangle|Rectangle $rect_or_quad rectangle region or quadrangle region to mask
     * @param int $pixel_expand expand offset in pixels for each point (0 by default)
     * @return Image|null Pointer to a masked image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneMasked(\Quadrangle|\Rectangle $rect_or_quad, int $pixel_expand = 0) : ?\Image {}

    /**
     * Fills image region specified by rectangle and color. The method will use
     * the first as many channel values as there are channels in the image
     * @param Quadrangle|Rectangle $rect_or_quad rectangle region or quadrangle region to fill
     * @param int $ch1 1-st channel value
     * @param int $ch2 2-nd channel value
     * @param int $ch3 3-rd channel value
     * @param int $ch4 4-th channel value
     * @param int $pixel_expand expand offset in pixels for each point (0 by default)
     */
    public function Fill(\Quadrangle|Rectangle $rect_or_quad, int $ch1, int $ch2 = 0, int $ch3 = 0, int $ch4 = 0, int $pixel_expand = 0) : void {}

    /**
     * Clone the image with filled region specified by rectangle and color. The method will use
     * the first as many channel values as there are channels in the image
     * @param Quadrangle|Rectangle $rect_or_quad rectangle region or quadrangle region to fill
     * @param int $ch1 1-st channel value
     * @param int $ch2 2-nd channel value
     * @param int $ch3 3-rd channel value
     * @param int $ch4 4-th channel value
     * @param int $pixel_expand expand offset in pixels for each point (0 by default)
     * @return Image|null Pointer to a filled image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneFilled(\Quadrangle|\Rectangle $rect_or_quad, int $ch1, int $ch2 = 0, int $ch3 = 0, int $ch4 = 0, int $pixel_expand = 0) : ?\Image {}

    /**
     * Flips an image around the vertical axis
     */
    public function FlipVertical() : void {}

    /**
     * Clones the image flipped around the vertical axis
     * @return Image|null Pointer to a flipped image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneFlippedVertical() : ?\Image {}

    /**
     * Flips an image around the horizontal axis
     */
    public function FlipHorizontal() : void {}

    /**
     * Clones the image flipped around the horizontal axis
     * @return Image|null Pointer to a flipped image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneFlippedHorizontal() : ?\Image {}

    /**
     * Rotates the image clockwise by a multiple of 90 degrees
     * @param int $times the number of times to rotate
     */
    public function Rotate90(int $times) : void {}

    /**
     * Clones the image rotated clockwise by a multiple of 90 degrees
     * @param int $times the number of times to rotate
     * @return Image|null Pointer to a rotated image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneRotated90(int $times) : ?\Image {}


    /**
     * Makes a single-channel image with averaged intensity values
     */
    public function AverageChannels() : void {}

    /**
     * Clones the image with averaged channel intensity values
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it.
     */
    public function CloneAveragedChannels() : ?\Image {}

    /**
     * Inverts the colors of the image
     */
    public function Invert() : void {}

    /**
     * Clones the image with inverted colos
     * @return Image|null Pointer to a created image. New object is allocated, the caller
     *         is responsible for deleting it
     */
    public function CloneInverted() : ?\Image {}

    /**
     *  Gets the image width in pixels
     */
    public function GetWidth() : int {}

    /**
     *  Gets the image height in pixels
     */
    public function GetHeight() : int {}

    /**
     *  Gets the image size in pixels
     */
    public function GetSize() : \Size {}

    /**
     *  Gets the number of image row in bytes, including alignment
     */
    public function GetStride() : int {}

    /**
     *  Gets the number of channels per pixel
     */
    public function GetChannels() : int {}

    /**
     *  Returns whether this instance owns and will release pixel data
     */
    public function IsMemoryOwner() : bool {}

    /**
     *  Forces memory ownership - allocates new image data and copies the pixels
     */
    public function ForceMemoryOwner() : void {}

    /**
     *  Serializes the image given the serializer object
     */    
    public function Serialize(\Serializer $serializer) : void {}

    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class ImagesMapIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\ImagesMapIterator $other) {}
    public function GetKey() : ?string {}
    public function GetValue() : \Image {}
    public function Equals(\ImagesMapIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class MutableString implements \SWIG\wrapped {

    // methods
    public function __construct(\MutableString|string $c_str_or_other) {}
    public function GetCStr() : ?string {}
    public function GetLength() : int {}
    public function Serialize(\Serializer $serializer) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class OcrChar implements \SWIG\wrapped {

    // methods

    /**
     * Main ctor from an array of variants
     * @param OcrChar|OcrCharVariant|null $variants_or_other pointer to an array of variants or other object
     * @param int|null $variants_count the number of variants in the array
     * @param bool $is_highlighted highlight flag for the OcrChar
     * @param Quadrangle|null $quad quadrangle of the OcrChar
     */
    public function __construct(\OcrChar|\OcrCharVariant|null $variants_or_other, int $variants_count = null, bool $is_highlighted = null, \Quadrangle $quad = null) {}
    public function GetVariantsCount() : int {}
    public function GetVariants() : ?\OcrCharVariant {}
    public function GetVariant(int $index) : \OcrCharVariant {}
    public function GetMutableVariant(int $index) : \OcrCharVariant {}
    public function SetVariant(int $index, \OcrCharVariant $v) : void {}
    public function Resize(int $size) : void {}
    public function GetIsHighlighted() : bool {}
    public function SetIsHighlighted(bool $is_highlighted) : void {}
    public function GetQuadrangle() : \Quadrangle {}
    public function GetMutableQuadrangle() : \Quadrangle {}
    public function SetQuadrangle(\Quadrangle $quad) : void {}
    public function SortVariants() : void {}
    public function GetFirstVariant() : \OcrCharVariant {}
    public function Serialize(\Serializer $serializer) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class OcrCharVariant implements \SWIG\wrapped {

    // methods

    /**
     * Ctor from utf8-char represented as a mutable string
     * @param MutableString|string $utf8_char utf8-character represented as a mutable string
     * @param float $confidence float confidence in range [0, 1]
     */
    public function __construct(\MutableString|string $utf8_char, float $confidence) {}
    public function GetCharacter() : ?string {}
    public function SetCharacter(\MutableString|string $utf8_char) : void {}
    public function GetConfidence() : float {}
    public function SetConfidence(float $confidence) : void {}
    public function GetInternalScore() : float {}
    public function SetInternalScore(float $internal_score) : void {}
    public function Serialize(\Serializer $serializer) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class OcrString implements \SWIG\wrapped {

    // methods

    /**
     * Ctor from an array of characters
     * @param OcrChar|OcrString|null|string $utf8_str_or_chars_or_other array of OcrChars, utf8 or other object
     * @param int|null $chars_count the number of characters
     */
    public function __construct(\OcrChar|\OcrString|null|string $utf8_str_or_chars_or_other, int $chars_count = null) {}
    public function GetCharsCount() : int {}
    public function GetChars() : ?\OcrChar {}
    public function GetChar(int $index) : \OcrChar {}
    public function GetMutableChar(int $index) : \OcrChar {}
    public function SetChar(int $index, \OcrChar $chr) : void {}
    public function AppendChar(\OcrChar $chr) : void {}
    public function AppendString(\OcrString $str) : void {}
    public function Resize(int $size) : void {}
    public function GetQuadrangleByIndex(int $idx) : \Quadrangle {}
    public function GetBestVariantConfidenceByIndex(int $idx) : float {}
    public function SortVariants() : void {}
    public function GetFirstString() : \MutableString {}
    public function UnpackChars() : void {}
    public function RepackChars() : void {}
    public function Serialize(\Serializer $serializer) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class Point implements \SWIG\wrapped {

    // methods
    public function __construct(float $x, float $y) {}
    public function Serialize(\Serializer $serializer) : void {}
    public function x_set(float $value) : void {}
    public function x_get() : float {}
    public function y_set(float $value) : void {}
    public function y_get() : float {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class Polygon implements \SWIG\wrapped {

    // methods
    public function __construct(\Point|\Polygon|null $points_or_other, int $points_count = null) {}
    public function GetPointsCount() : int {}
    public function GetPoints() : ?\Point {}
    public function GetPoint(int $index) : \Point {}
    public function GetMutablePoint(int $index) : \Point {}
    public function SetPoint(int $index, \Point $p) : void {}
    public function Resize(int $size) : void {}
    public function GetBoundingRectangle() : \Rectangle {}
    public function Serialize(\Serializer $serializer) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class ProjectiveTransform implements \SWIG\wrapped {

    // methods

    /**
     * Returns true, iff the projective transform can be defined which
     *        transforms the quad 'src_quad' to an orthotropic rectangle
     *        with size 'dst_size'
     * @param Quadrangle $src_quad transformation source
     * @param Quadrangle|Size $dst_quad_or_dst_size transformation destination or linear sizes of the transformation destionation
     * @return bool true iff such transform can be defined and constructed
     */
    public static function CanCreate(\Quadrangle $src_quad, \Quadrangle|\Size $dst_quad_or_dst_size) : bool {}

    /**
     * Creates a transformation which transforms the quad 'src_quad' to
     *        the quad 'dst_quad' or to an orthotropic rectangle
     *        with size 'dst_size'
     * @param Quadrangle $src_quad transformation source
     * @param Quadrangle|Size $dst_quad_or_dst_size transformation destination or linear sizes of the transformation destionation
     * @return ProjectiveTransform|null Created transform
     */
    public static function Create(\Quadrangle $src_quad, \Quadrangle|\Size $dst_quad_or_dst_size) : ?\ProjectiveTransform {}
    public function c_Clone() : ?\ProjectiveTransform {}
    public function TransformPoint(\Point $p) : \Point {}
    public function TransformQuad(\Quadrangle $q) : \Quadrangle {}
    public function TransformPolygon(\Polygon $poly) : \Polygon {}
    public function IsInvertable() : bool {}
    public function Invert() : void {}
    public function CloneInverted() : ?\ProjectiveTransform {}
    public function Serialize(\Serializer $serializer) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class Quadrangle implements \SWIG\wrapped {

    // methods
    public function __construct(\Point $a, \Point $b, \Point $c, \Point $d) {}
    public function GetPoint(int $index) : \Point {}
    public function GetMutablePoint(int $index) : \Point {}
    public function SetPoint(int $index, \Point $p) : void {}
    public function GetBoundingRectangle() : \Rectangle {}
    public function Serialize(\Serializer $serializer) : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class QuadranglesMapIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\QuadranglesMapIterator $other) {}
    public function GetKey() : ?string {}
    public function GetValue() : \Quadrangle {}
    public function Equals(\QuadranglesMapIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class Rectangle implements \SWIG\wrapped {

    // methods
    public function __construct(int $x, int $y, int $width, int $height) {}
    public function Serialize(\Serializer $serializer) : void {}
    public function x_set(int $value) : void {}
    public function x_get() : int {}
    public function y_set(int $value) : void {}
    public function y_get() : int {}
    public function width_set(int $value) : void {}
    public function width_get() : int {}
    public function height_set(int $value) : void {}
    public function height_get() : int {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class SerializationParameters implements \SWIG\wrapped {

    // methods
    public function __construct(\SerializationParameters $copy) {}

    /**
     * Checks whether the serialization parameters have an
     *        ignored object type
     * @param string $object_type the name of the object type to check
     * @return bool true iff the object type 'object_type' is ignored
     */
    public function HasIgnoredObjectType(string $object_type) : bool {}

    /**
     * Adds an object type to the set of ignored
     * @param string $object_type the name of the object type to add
     */
    public function AddIgnoredObjectType(string $object_type) : void {}

    /**
     * Removes an object type from the set of ignored
     * @param string $object_type the name of the object type to remove
     */
    public function RemoveIgnoredObjectType(string $object_type) : void {}
    public function IgnoredObjectTypesBegin() : \StringsSetIterator {}
    public function IgnoredObjectTypesEnd() : \StringsSetIterator {}

    /**
     * Checks whether the serialization parameters have an ignored key
     * @param string $key the name of the key to check
     * @return bool true iff the key 'key' is ignored
     */
    public function HasIgnoredKey(string $key) : bool {}

    /**
     * Adds a key to the set of ignored keys
     * @param string $key the name of the key to add
     */
    public function AddIgnoredKey(string $key) : void {}

    /**
     * Removes a key from the set of ignored keys
     * @param string $key the name of the key to remove
     */
    public function RemoveIgnoredKey(string $key) : void {}
    public function IgnoredKeysBegin() : \StringsSetIterator {}
    public function IgnoredKeysEnd() : \StringsSetIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class Serializer implements \SWIG\wrapped {

    // methods
    public function Reset() : void {}
    public function GetCStr() : ?string {}
    public function SerializerType() : ?string {}

    /**
     * Factory method for creating a JSON serializer object
     * @param SerializationParameters $params serialization parameters
     * @return Serializer|null Pointer to a constructed serializer object. New object is created,
     *         the caller is responsible for deleting it.
     */
    public static function CreateJSONSerializer(\SerializationParameters $params) : ?\Serializer {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class Size implements \SWIG\wrapped {

    // methods
    public function __construct(int $width, int $height) {}
    public function Serialize(\Serializer $serializer) : void {}
    public function width_set(int $value) : void {}
    public function width_get() : int {}
    public function height_set(int $value) : void {}
    public function height_get() : int {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class StringsMapIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\StringsMapIterator $other) {}
    public function GetKey() : ?string {}
    public function GetValue() : ?string {}
    public function Equals(\StringsMapIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class StringsSet implements \SWIG\wrapped {

    // methods
    public function GetStringsCount() : int {}
    public function HasString(string $string) : bool {}
    public function StringsBegin() : \StringsSetIterator {}
    public function StringsEnd() : \StringsSetIterator {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class StringsSetIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\StringsSetIterator $other) {}
    public function GetValue() : ?string {}
    public function Equals(\StringsSetIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class StringsVectorIterator implements \SWIG\wrapped {

    // methods
    public function __construct(\StringsVectorIterator $other) {}
    public function GetValue() : ?string {}
    public function Equals(\StringsVectorIterator $rvalue) : bool {}
    public function Advance() : void {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class YUVDimensions implements \SWIG\wrapped {

    // methods
    public function __construct(int $y_pixel_stride, int $y_row_stride, int $u_pixel_stride, int $u_row_stride, int $v_pixel_stride, int $v_row_stride, int $width, int $height, int $type) {}
    public function yPlanePixelStride_set(int $value) : void {}
    public function yPlanePixelStride_get() : int {}
    public function yPlaneRowStride_set(int $value) : void {}
    public function yPlaneRowStride_get() : int {}
    public function uPlanePixelStride_set(int $value) : void {}
    public function uPlanePixelStride_get() : int {}
    public function uPlaneRowStride_set(int $value) : void {}
    public function uPlaneRowStride_get() : int {}
    public function vPlanePixelStride_set(int $value) : void {}
    public function vPlanePixelStride_get() : int {}
    public function vPlaneRowStride_set(int $value) : void {}
    public function vPlaneRowStride_get() : int {}
    public function width_set(int $value) : void {}
    public function width_get() : int {}
    public function height_set(int $value) : void {}
    public function height_get() : int {}
    public function type_set(int $value) : void {}
    public function type_get() : int {}
    public function __set(string $var, $value = null) : void {}
    public function __get(string $var) {}
    public function __isset(string $var) : bool {}
}

class phpidengine {

    // constants
    const IPF_G = 0;
    const IPF_GA = 1;
    const IPF_AG = 2;
    const IPF_RGB = 3;
    const IPF_BGR = 4;
    const IPF_BGRA = 5;
    const IPF_ARGB = 6;
    const IPF_RGBA = 7;
    const YUVTYPE_UNDEFINED = 0;
    const YUVTYPE_NV21 = 1;
    const YUVTYPE_420_888 = 2;
    const IdFieldType_Text = 0;
    const IdFieldType_Image = 1;
    const IdFieldType_Animated = 2;
    const IdFieldType_Check = 3;
    const IdCheckStatus_Undefined = 0;
    const IdCheckStatus_Passed = 1;
    const IdCheckStatus_Failed = 2;
    const IdFaceOrientation_0 = 0;
    const IdFaceOrientation_90CW = 1;
    const IdFaceOrientation_180 = 2;
    const IdFaceOrientation_270CW = 3;
    const IdFaceStatus_NotUsed = 0;
    const IdFaceStatus_Success = 1;
    const IdFaceStatus_A_FaceNotFound = 2;
    const IdFaceStatus_B_FaceNotFound = 3;
    const IdFaceStatus_FaceNotFound = 4;
    const IdFaceStatus_NoAccumulatedResult = 5;
}

const IPF_AG = 2;
const IPF_ARGB = 6;
const IPF_BGR = 4;
const IPF_BGRA = 5;
const IPF_G = 0;
const IPF_GA = 1;
const IPF_RGB = 3;
const IPF_RGBA = 7;
const IdCheckStatus_Failed = 2;
const IdCheckStatus_Passed = 1;
const IdCheckStatus_Undefined = 0;
const IdFaceOrientation_0 = 0;
const IdFaceOrientation_90CW = 1;
const IdFaceOrientation_180 = 2;
const IdFaceOrientation_270CW = 3;
const IdFaceStatus_A_FaceNotFound = 2;
const IdFaceStatus_B_FaceNotFound = 3;
const IdFaceStatus_FaceNotFound = 4;
const IdFaceStatus_NoAccumulatedResult = 5;
const IdFaceStatus_NotUsed = 0;
const IdFaceStatus_Success = 1;
const IdFieldType_Animated = 2;
const IdFieldType_Check = 3;
const IdFieldType_Image = 1;
const IdFieldType_Text = 0;
const YUVTYPE_420_888 = 2;
const YUVTYPE_NV21 = 1;
const YUVTYPE_UNDEFINED = 0;
const swig_runtime_data_type_pointer = 140405775507968;
}

namespace SWIG {
class _int implements \SWIG\wrapped {
}

class _p_int implements \SWIG\wrapped {
}

class _p_long_long implements \SWIG\wrapped {
}

class _p_short implements \SWIG\wrapped {
}

class _p_signed_char implements \SWIG\wrapped {
}

class _p_unsigned_char implements \SWIG\wrapped {
}

class _p_unsigned_int implements \SWIG\wrapped {
}

class _p_unsigned_long_long implements \SWIG\wrapped {
}

class _p_unsigned_short implements \SWIG\wrapped {
}

}
